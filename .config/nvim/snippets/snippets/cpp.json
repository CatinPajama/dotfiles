{
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template <class T> class Seg {",
      "public:",
      "  vector<T> segtree;",
      "  int len;",
      "  function<T(T, T)> comb;",
      "  T DEFAULT = 0;",
      "  Seg(int l, function<T(T, T)> c, T d) {",
      "    segtree.assign(2 * l, d);",
      "    len = l;",
      "    DEFAULT = d;",
      "    comb = c;",
      "  }",
      "  void set(int ind, T val) {",
      "    assert(0 <= ind && ind < len);",
      "    ind += len;",
      "    segtree[ind] = val;",
      "    for (; ind > 1; ind /= 2) {",
      "      segtree[ind >> 1] = comb(segtree[ind], segtree[ind ^ 1]);",
      "    }",
      "  }",
      "  T query(int start, int end) {",
      "    end++;",
      "    assert(0 <= start && start < len && 0 < end && end <= len);",
      "    T sum = DEFAULT;",
      "    for (start += len, end += len; start < end; start /= 2, end /= 2) {",
      "      if ((start & 1) != 0) {",
      "        sum = comb(sum, segtree[start++]);",
      "      }",
      "      if ((end & 1) != 0) {",
      "        sum = comb(sum, segtree[--end]);",
      "      }",
      "    }",
      "    return sum;",
      "  }",
      "};",
      "",
      ""
    ],
    "description": "segtree"
  },
  "disjointset": {
    "prefix": "disjointset",
    "body": [
      "",
      "class DSU {",
      "private:",
      "  vector<int> parents;",
      "  vector<int> sizes;",
      "",
      "public:",
      "  DSU(int size) : parents(size), sizes(size, 1) {",
      "    for (int i = 0; i < size; i++) {",
      "      parents[i] = i;",
      "    }",
      "  } /** @return the \"representative\" node in x's component */",
      "  int find(int x) {",
      "    return parents[x] == x ? x : (parents[x] = find(parents[x]));",
      "  } /** @return whether the merge changed connectivity */",
      "  bool unite(int x, int y) {",
      "    int x_root = find(x);",
      "    int y_root = find(y);",
      "    if (x_root == y_root) {",
      "      return false;",
      "    }",
      "    if (sizes[x_root] < sizes[y_root]) {",
      "      swap(x_root, y_root);",
      "    }",
      "    sizes[x_root] += sizes[y_root];",
      "    parents[y_root] = x_root;",
      "    return true;",
      "  } /** @return whether x and y are in the same connected component */",
      "  bool connected(int x, int y) { return find(x) == find(y); }",
      "};",
      "",
      ""
    ],
    "description": "disjointset"
  },
  "BIT": {
    "prefix": "BIT",
    "body": [
      "template <class T> class BIT {",
      "private:",
      "  int size;",
      "  vector<T> bit;",
      "  vector<T> arr;",
      "",
      "public:",
      "  BIT(int s) : size(s), bit(size + 1), arr(size) {}",
      "  void set(int ind, T val) { add(ind, val - arr[ind]); }",
      "  void add(int ind, T val) {",
      "    arr[ind] += val;",
      "    ind++;",
      "    for (; ind <= size; ind += ind & -ind) {",
      "      bit[ind] += val;",
      "    }",
      "  }",
      "  T pref_sum(int ind) {",
      "    ind++;",
      "    T total = 0;",
      "    for (; ind > 0; ind -= ind & -ind) {",
      "      total += bit[ind];",
      "    }",
      "    return total;",
      "  }",
      "};",
      "",
      ""
    ],
    "description": "BIT"
  },
  "math": {
    "prefix": "math",
    "body": [
      "",
      "struct Mint {",
      "  int val;",
      "  Mint(int _val = 0) { val = _val % MOD; }",
      "  Mint operator+(Mint oth) { return val + oth.val; }",
      "  Mint operator*(Mint oth) { return 1LL * val * oth.val; }",
      "  Mint operator-(Mint oth) { return val - oth.val + MOD; }",
      "",
      "  void operator+=(Mint oth) { val = (Mint(val) + oth).val; }",
      "  void operator-=(Mint oth) { val = (Mint(val) - oth).val; }",
      "  void operator*=(Mint oth) { val = (Mint(val) * oth).val; }",
      "};",
      "",
      "vector<int> fact, invf;",
      "",
      "int qexp(int a, int b, int m) {",
      "  int res = 1;",
      "  while (b) {",
      "    if (b % 2)",
      "      res = res * a % m;",
      "    a = a * a % m;",
      "    b /= 2;",
      "  }",
      "  return res % m;",
      "}",
      "",
      "void precompute(int n) {",
      "  fact.assign(n + 1, 1);",
      "  for (int i = 1; i <= n; i++)",
      "    fact[i] = fact[i - 1] * i % MOD;",
      "  invf.assign(n + 1, 1);",
      "  invf[n] = qexp(fact[n], MOD - 2, MOD);",
      "  for (int i = n - 1; i > 0; i--)",
      "    invf[i] = invf[i + 1] * (i + 1) % MOD;",
      "}",
      ""
    ],
    "description": "math"
  },
  "binarysearch": {
    "prefix": "binarysearch",
    "body": [
      "int last_true(int lo, int hi, function<bool(int)> f) {",
      "  lo--;",
      "  while (lo < hi) {",
      "    int mid = lo + (hi - lo + 1) / 2;",
      "    if (f(mid)) {",
      "      lo = mid;",
      "    } else {",
      "      hi = mid - 1;",
      "    }",
      "  }",
      "  return lo;",
      "}",
      "int first_true(int lo, int hi, function<bool(int)> f) {",
      "  hi++;",
      "  while (lo < hi) {",
      "    int mid = lo + (hi - lo) / 2;",
      "    if (f(mid)) {",
      "      hi = mid;",
      "    } else {",
      "      lo = mid + 1;",
      "    }",
      "  }",
      "  return lo;",
      "}",
      "",
      ""
    ],
    "description": "binarysearch"
  },
  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T>",
      "using oset =",
      "    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      ""
    ],
    "description": "pbds"
  }
}

